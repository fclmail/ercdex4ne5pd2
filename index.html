<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>G116-D2</title>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <style>
    body { background-color: #0a0; color: white; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; padding: 20px; }
    table { border-collapse: collapse; width: 100%; margin-top: 20px; }
    th, td { padding: 8px 12px; border: 1px solid #444; text-align: center; }
    .profitable { background-color: #00ff00; color: black; font-weight: bold; }
    #log { max-height: 220px; overflow-y: auto; border: 1px solid #444; margin-top: 10px; padding: 10px; background: #111; }
    button { padding: 8px 16px; margin: 5px; background: #333; color: white; border: none; border-radius: 4px; cursor: pointer; }
    button:hover { background: #555; }
    .control-group { margin: 10px 0; display: flex; flex-wrap: wrap; align-items: center; gap: 15px; }
    .control-group label { display: flex; align-items: center; gap: 6px; }
    .profit-display { font-size: 1.1em; font-weight: bold; margin: 10px 0; padding: 8px; background: #333; border-radius: 4px; }
    .subtle { opacity: .9; font-weight: 600; }
    input[type="number"] { width: 90px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  </style>
</head>
<body>
  <h1>G116-D2</h1>
  <p><strong>Wallet:</strong> <span id="wallet" class="mono">-</span></p>
  <p><strong>Wallet USDC Balance:</strong> <span id="walletBalance" class="mono">-</span></p>
  <p><strong>Contract USDC Balance:</strong> <span id="contractBalance" class="mono">-</span></p>
  <div class="profit-display">
    <strong>Accumulated Profit:</strong> <span id="accumulatedProfit" class="mono">0.00</span> USDC
  </div>

  <div class="control-group">
    <button id="connectWallet">Connect Wallet</button>
    <button id="scanNow">Scan Now</button>
    <button id="withdrawUSDC">Withdraw USDC</button>
    <button id="startScan">Start</button>
    <button id="stopScan">Stop</button>
    <button id="pauseScan">Pause</button>
  </div>

  <div class="control-group">
    <label><input type="checkbox" id="autoTradeToggle"> Auto Trade</label>
    <label><input type="checkbox" id="backgroundTradeToggle"> Auto Trade in Background</label>
    <label><input type="checkbox" id="accumulateToggle"> Let profits accumulate in contract</label>
    <label><input type="checkbox" id="positiveBalanceToggle" checked> Only trade if contract balance increases</label>
  </div>

  <div class="control-group">
    <label>Min Profit %: <input type="number" id="minProfitPct" value="0.2" step="0.1" min="0.1">%</label>
    <label>Trade Amount: <input type="number" id="tradeAmount" value="10" min="1"> USDC</label>
    <label>Batch Trades (1-100): <input type="number" id="batchCount" value="1" min="1" max="100" step="1"></label>
    <label>Slippage %: <input type="number" id="slippagePct" value="0" step="0.1" min="0">%</label>
  </div>

  <!-- New: Scan interval + callStatic toggle -->
  <div class="control-group">
    <label>
      Scan interval:
      <input type="range" id="scanIntervalSec" min="0" max="100" value="30" step="1">
      <span id="scanIntervalLabel" class="subtle mono">30s</span>
    </label>
    <label title="If ON: we still show raw üö® opportunities, but add ‚úÖ when callStatic also shows profit. Auto-Trade will require ‚úÖ.">
      <input type="checkbox" id="callStaticToggle" checked>
      Require callStatic confirmation for Auto-Trade <span class="mono">‚úÖ</span>
    </label>
  </div>

  <table id="resultTable">
    <thead>
      <tr>
        <th>Token</th>
        <th>Buy Router</th>
        <th>Sell Router</th>
        <th>Buy Price (USDC)</th>
        <th>Sell Price (USDC)</th>
        <th>Profit (USDC)</th>
        <th>Profit %</th>
        <th>Status</th>
        <th>Action</th>
      </tr>
    </thead>
    <tbody id="results"></tbody>
  </table>

  <div id="log"></div>

  <div class="control-group">
    <button id="exportCSV">Export Successful Transactions</button>
  </div>

  <script>
    // -------------------------
    // CONFIG / PLACEHOLDERS
    // -------------------------
    let transactionHistory = [];
    const contractAddress = "0x19B64f74553eE0ee26BA01BF34321735E4701C43";
    const contractABI = [
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "buyRouter",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "sellRouter",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "token",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "amountIn",
				"type": "uint256"
			}
		],
		"name": "executeArbitrage",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "asset",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "premium",
				"type": "uint256"
			},
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			},
			{
				"internalType": "bytes",
				"name": "params",
				"type": "bytes"
			}
		],
		"name": "executeOperation",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "_minProfit",
				"type": "uint256"
			}
		],
		"name": "setMinProfit",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "_aavePool",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "_usdc",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "_minProfit",
				"type": "uint256"
			}
		],
		"stateMutability": "nonpayable",
		"type": "constructor"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "token",
				"type": "address"
			}
		],
		"name": "withdrawProfit",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "AAVE_POOL",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "minProfit",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "owner",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "USDC",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	}
 ];

    // Tokens with address + decimals (display-safe)
    const tokens = {
      AAVE:{address:"0xd6df932a45c0f255f85145f286ea0b292b21c90b",decimals:18},
      APE:{address:"0x4d224452801aced8b2f0aebe155379bb5d594381",decimals:18},
      AXLUSDC:{address:"0x2a2b6055a5c6945f4fe0e814f5d4a13b5a681159",decimals:6},
      BETA:{address:"0x0afaabcad8815b32bf2b64e0dc5e1df2f1454cde",decimals:18},
      BONE:{address:"0xad37e3433ebde20e5fbf531e6c7da1655c60bb8e",decimals:18},
      CRV:{address:"0x172370d5cd63279efa6d502dab29171933a610af",decimals:18},
      DAI:{address:"0x8f3cf7ad23cd3cadbd9735aff958023239c6a063",decimals:18},
      DPI:{address:"0x1494ca1f11d487c2bbe4543e90080aeba4ba3c2b",decimals:18},
      FND:{address:"0x292c4eefdda27062049d44d4730d5fe774b5f4c7",decimals:18},
      FREE:{address:"0xe1ae4d4a3a2200ae5ac06e50bca0dd7e52a19238",decimals:18},
      KLIMA:{address:"0x4e78011ce80ee02d2c3e649fb657e45898257815",decimals:9},
      LDO:{address:"0xbb0bb78beeea5cf201b8f2651f48830e64ce45a4",decimals:18},
      LINK:{address:"0x53e0bca35ec356bd5dddfebbd1fc0fd03fabad39",decimals:18},
      MATICX:{address:"0xa3fa99a148fa48d14ed51d610c367c61876997f1",decimals:18},
      OS:{address:"0xd3a691c852cdb01e281545a27064741f0b7f6825",decimals:18},
      QUICK:{address:"0x831753dd7087cac61ab5644b308642cc1c33dc13",decimals:18},
      RNDR:{address:"0x6c3c7886b43d005db8c28a09e8038b87e36cf26c",decimals:18},
      SHIB:{address:"0x6f8a06447ff6fcf75a5fcdb3f8c4bab2da4fc0d0",decimals:18},
      SHIKIGON:{address:"0x3f0fb6e42d160a8def49fe68b8ef4d8a5b7ab119",decimals:18},
      SURE:{address:"0xf638a9594c0c780d6c8bc40fa33efb0ceabf5d57",decimals:18},
      THE7:{address:"0x045f7ffdcc8334e78316a2c1164efb2e5f3815d5",decimals:18},
      TRADE:{address:"0x82362ec182db3cf7829014bc61e9be8a2e82868a",decimals:18},
      UNI:{address:"0x1f9840a85d5af5bf1d1762f925bdaddc4201f984",decimals:18},
      UNI2:{address:"0xb33eaad8d922b1083446dc23f610c2567fb5180f",decimals:18}, // separate key
      USDC:{address:"0x2791bca1f2de4661ed88a30c99a7a9449aa84174",decimals:6},
      USDT:{address:"0xc2132d05d31c914a87c6611c10748aeb04b58e8f",decimals:6},
      WBTC:{address:"0x1bfd67037b42cf73acf2047067bd4f2c47d9bfd6",decimals:8},
      WETH:{address:"0x7ceb23fd6bc0add59e62ac25578270cff1b9f619",decimals:18},
      XSGD:{address:"0x70e8de73ce022f373d5a9f00b0ec0cf5835b0fc0",decimals:6}
    };

    const routers = {
      QuickSwap: "0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff",
      SushiSwap: "0x1b02da8cb0d097eb8d57a175b88c7d8b47997506",
      Dfyn: "0xA8b607Aa09B6A2641cF6F90f643E76d3f6e6Ff73",
      ApeSwap: "0xC0788A3aD43d79aa53B09c2EaCc313A787d1d607"
    };

    // -------------------------
    // STATE
    // -------------------------
    let provider, signer, contract, walletAddress;
    let isScanning = false;
    let scanInterval;
    let accumulatedProfit = 0;

    // -------------------------
    // INIT
    // -------------------------
    window.addEventListener('load', function() {
      document.getElementById('connectWallet').addEventListener('click', connectWallet);
      document.getElementById('scanNow').addEventListener('click', manualScan);
      document.getElementById('withdrawUSDC').addEventListener('click', withdrawUSDC);
      document.getElementById('scanIntervalSec').addEventListener('input', onScanIntervalChange);
      document.getElementById('callStaticToggle').addEventListener('change', ()=>{/* UI only; logic reads live */});
      restoreTransactionHistory();
      // initialize label
      onScanIntervalChange();
    });

    // -------------------------
    // WALLET / BALANCES
    // -------------------------
    async function connectWallet() {
      try {
        if (!window.ethereum) throw new Error("MetaMask or other Web3 provider not found");
        provider = new ethers.providers.Web3Provider(window.ethereum);
        await provider.send("eth_requestAccounts", []);
        signer = provider.getSigner();
        walletAddress = await signer.getAddress();
        document.getElementById("wallet").textContent = walletAddress;
        contract = new ethers.Contract(contractAddress, contractABI, signer);
        await updateBalances();
        startAutoScan(); // start with current slider value
        log("Wallet connected successfully");
      } catch (error) {
        log(`‚ö†Ô∏è Wallet connection failed: ${error.message}`);
      }
    }

    function fmt(num, maxFrac = 6) {
      if (!isFinite(num)) return "-";
      // limit very tiny values to scientific-ish small display
      if (Math.abs(num) < 1e-6 && num !== 0) return num.toExponential(2);
      return Number(num).toLocaleString(undefined, { maximumFractionDigits: maxFrac });
    }

    async function updateBalances() {
      try {
        if (!provider || !walletAddress) return;
        const usdcAddr = tokens.USDC.address;
        const usdc = new ethers.Contract(
          usdcAddr,
          ["function balanceOf(address) view returns (uint256)", "function decimals() view returns (uint8)"],
          provider
        );
        const decimals = await usdc.decimals();
        const [balance, contractBal] = await Promise.all([
          usdc.balanceOf(walletAddress),
          usdc.balanceOf(contractAddress),
        ]);
        document.getElementById("walletBalance").textContent = fmt(ethers.utils.formatUnits(balance, decimals), 6);
        document.getElementById("contractBalance").textContent = fmt(ethers.utils.formatUnits(contractBal, decimals), 6);
      } catch (error) {
        log(`‚ö†Ô∏è Balance update failed: ${error.message}`);
      }
    }

    // -------------------------
    // SCAN / ARBITRAGE
    // -------------------------
    function currentIntervalMs() {
      const sec = parseInt(document.getElementById('scanIntervalSec').value || "30", 10);
      return Math.max(0, Math.min(100, sec)) * 1000;
    }

    function onScanIntervalChange() {
      const sec = parseInt(document.getElementById('scanIntervalSec').value || "30", 10);
      document.getElementById('scanIntervalLabel').textContent = `${sec}s`;
      // If timer active, restart with new interval
      if (scanInterval) {
        startAutoScan();
      }
    }

    function startAutoScan() {
      if (scanInterval) clearInterval(scanInterval);
      const iv = currentIntervalMs();
      if (iv === 0) {
        // "Rapid fire" mode: queue next scan as soon as previous finishes
        scanInterval = setInterval(() => {
          if (!isScanning) scanAndArbitrage();
        }, 250); // small tick to trigger ASAP when free
      } else {
        scanInterval = setInterval(() => {
          if (!isScanning) scanAndArbitrage();
        }, iv);
      }
      log(`Auto scan interval set to ${fmt(iv/1000, 0)}s`);
    }

    async function manualScan() {
      if (isScanning) { log("Scan already in progress"); return; }
      await scanAndArbitrage();
    }

    async function scanAndArbitrage() {
      if (!walletAddress) { log("Please connect your wallet first"); return; }
      isScanning = true;
      document.getElementById("results").innerHTML = "";
      log("Starting arbitrage scan...");
      try {
        const minProfitPct = parseFloat(document.getElementById("minProfitPct").value);
        const tradeAmount = parseFloat(document.getElementById("tradeAmount").value);
        const slippagePct = parseFloat(document.getElementById("slippagePct").value);
        const requireStatic = document.getElementById("callStaticToggle").checked;
        const amountIn = ethers.utils.parseUnits(tradeAmount.toString(), 6); // USDC has 6

        for (const [symbol, meta] of Object.entries(tokens)) {
          const token = meta.address;
          for (const [buyName, buyRouter] of Object.entries(routers)) {
            for (const [sellName, sellRouter] of Object.entries(routers)) {
              if (buyName === sellName) continue;
              try {
                // RAW path (lots of opportunities) ‚Äî unchanged
                const buyOut = await getAmountOut(buyRouter, token, amountIn, /*useCallStatic*/ false);
                const sellOut = await getAmountOut(sellRouter, token, amountIn, /*useCallStatic*/ false);

                // Prices (USDC per 1 token)
                const buyPrice = tradeAmount / buyOut;
                const sellPrice = tradeAmount / sellOut;
                const profitUSDC = sellPrice - buyPrice;
                const profitPct = (profitUSDC / buyPrice) * 100;

                // Optional callStatic confirmation (profit protection)
                let profitPctStatic = NaN;
                if (requireStatic) {
                  const buyOutStatic = await getAmountOut(buyRouter, token, amountIn, true);
                  const sellOutStatic = await getAmountOut(sellRouter, token, amountIn, true);
                  const buyPriceStatic = tradeAmount / buyOutStatic;
                  const sellPriceStatic = tradeAmount / sellOutStatic;
                  profitPctStatic = ((sellPriceStatic - buyPriceStatic) / buyPriceStatic) * 100;
                }

                // Slippage adjustment (applies only to displayed raw profit/percent)
                const slAdj = (1 - (slippagePct / 100));
                const slippageAdjustedProfitPct = profitPct * slAdj;
                const slippageAdjustedProfitUSDC = profitUSDC * slAdj;

                const row = document.createElement("tr");
                if (slippageAdjustedProfitPct > minProfitPct) row.classList.add("profitable");

                // Status symbols
                const getProfitable = slippageAdjustedProfitPct > minProfitPct; // raw
                const staticProfitable = requireStatic ? (profitPctStatic > minProfitPct) : false;
                let statusSymbols = '';
                if (getProfitable) statusSymbols += 'üö®';
                if (requireStatic && staticProfitable) statusSymbols += '‚úÖ';
                if (!statusSymbols) statusSymbols = '‚ùå Skip';

                // Action cell
                const actionCell = document.createElement("td");
                if (getProfitable) {
                  // If callStatic is required, only allow auto-trade when ‚úÖ present.
                  const canAutoTradeNow = !requireStatic || (requireStatic && staticProfitable);
                  const tradeBtn = document.createElement("button");
                  tradeBtn.textContent = "Trade";
                  tradeBtn.onclick = () => executeTrade(buyRouter, sellRouter, token, amountIn, symbol, slippageAdjustedProfitPct);
                  actionCell.appendChild(tradeBtn);

                  // Auto-trade logic respects callStatic toggle when ON
                  if (document.getElementById("autoTradeToggle").checked && canAutoTradeNow) {
                    const backgroundMode = document.getElementById("backgroundTradeToggle").checked;
                    if (backgroundMode) {
                      executeTrade(buyRouter, sellRouter, token, amountIn, symbol, slippageAdjustedProfitPct)
                        .catch(e => log(`‚ö†Ô∏è Background trade failed for ${symbol}: ${e.message}`));
                    } else {
                      await executeTrade(buyRouter, sellRouter, token, amountIn, symbol, slippageAdjustedProfitPct);
                    }
                  }
                }

                row.innerHTML = `
                  <td>${symbol}</td>
                  <td>${buyName}</td>
                  <td>${sellName}</td>
                  <td class="mono">${fmt(buyPrice, 6)}</td>
                  <td class="mono">${fmt(sellPrice, 6)}</td>
                  <td class="mono">${fmt(slippageAdjustedProfitUSDC, 6)}</td>
                  <td class="mono">${fmt(slippageAdjustedProfitPct, 2)}%</td>
                  <td>${statusSymbols}</td>
                `;
                row.appendChild(actionCell);
                document.getElementById("results").appendChild(row);
              } catch (e) {
                log(`‚ö†Ô∏è ${symbol} ${buyName} ‚Üí ${sellName} failed: ${e.message}`);
              }
            }
          }
        }
      } catch (error) {
        log(`‚ö†Ô∏è Scan failed: ${error.message}`);
      } finally {
        isScanning = false;
        await updateBalances();
        log("Scan completed");
      }
    }

    // -------------------------
    // EXECUTE TRADE
    // -------------------------
    async function executeTrade(buyRouter, sellRouter, token, amountIn, symbol, profitPct) {
      try {
        const batchCount = Math.min(parseInt(document.getElementById("batchCount").value || "1"), 100);
        log(`‚ö° Executing arbitrage for ${symbol} (${profitPct.toFixed(2)}%) x${batchCount}...`);
        for (let i = 0; i < batchCount; i++) {
          const contractUSDCBefore = await getContractUSDCBalance();
       const tx = await contract.executeArbitrage(
  buyRouter,
  sellRouter,
  token,
  amountIn,
  { gasLimit: 1000000 }
);

          log(`Transaction ${i + 1}/${batchCount} sent: ${tx.hash}`);
          const receipt = await tx.wait();
          const contractUSDCAfter = await getContractUSDCBalance();
          const profit = contractUSDCAfter - contractUSDCBefore;

          // Optional guard: only count positive increases if toggle checked
          if (!document.getElementById("positiveBalanceToggle").checked || profit > 0) {
            if (profit > 0) {
              accumulatedProfit += profit;
              document.getElementById("accumulatedProfit").textContent = Number(accumulatedProfit).toFixed(2);
            }
          }

          const txDetails = {
            timestamp: Date.now(),
            txHash: receipt.transactionHash,
            symbol,
            profitBeforeFees: profitPct.toFixed(2) + '%',
            actualProfit: profit.toFixed(6) + ' USDC',
            contractBalanceAfter: contractUSDCAfter.toFixed(6) + ' USDC',
            buyDex: Object.keys(routers).find(k => routers[k] === buyRouter) || buyRouter,
            sellDex: Object.keys(routers).find(k => routers[k] === sellRouter) || sellRouter
          };
          logTransaction(txDetails);
          log(`‚úÖ Arbitrage ${i + 1}/${batchCount} done! Profit: ${profit.toFixed(6)} USDC`);
        }

        if (!document.getElementById("accumulateToggle").checked) {
  const withdrawTx = await contract.withdrawProfit(tokens.USDC.address);
  await withdrawTx.wait();
  log("üí∞ Profits withdrawn to your wallet");
}

        await updateBalances();
      } catch (error) {
        log(`‚ö†Ô∏è Arbitrage failed for ${symbol}: ${error.message}`);
        throw error;
      }
    }

    // -------------------------
    // HELPERS: Withdraw, balances
    // -------------------------
  async function withdrawUSDC() {
  try {
    log("Withdrawing USDC from contract...");
    const tx = await contract.withdrawProfit(tokens.USDC.address);
    await tx.wait();
    log("‚úÖ USDC withdrawn successfully");
    updateBalances();
  } catch (error) {
    log(`‚ö†Ô∏è Withdrawal failed: ${error.message}`);
  }
}


    async function getContractUSDCBalance() {
      const usdc = new ethers.Contract(
        tokens.USDC.address,
        ["function balanceOf(address) view returns (uint256)", "function decimals() view returns (uint8)"],
        provider
      );
      const decimals = await usdc.decimals();
      const balance = await usdc.balanceOf(contractAddress);
      return Number(ethers.utils.formatUnits(balance, decimals));
    }

    // -------------------------
    // LOGGING / PERSISTENCE
    // -------------------------
    function logTransaction(txDetails) {
      try {
        const logDiv = document.getElementById("log");
        const sessionNumber = transactionHistory.length + 1;
        const time = txDetails.timestamp ? new Date(txDetails.timestamp).toLocaleTimeString() : new Date().toLocaleTimeString();
        const profit = txDetails.actualProfit || '';
        const txLink = txDetails.txHash ? `<a href="https://polygonscan.com/tx/${txDetails.txHash}" target="_blank">${txDetails.txHash}</a>` : '';
        const displayRow = `${time} ${sessionNumber} ${txDetails.symbol || ''} BUY ${txDetails.buyDex || ''} SELL ${txDetails.sellDex || ''} NET PROFIT, ${profit} ${txLink}<br>`;
        logDiv.innerHTML = displayRow + logDiv.innerHTML;
        if (!txDetails.timestamp) txDetails.timestamp = Date.now();
        transactionHistory.push(txDetails);
        localStorage.setItem("transactionHistory", JSON.stringify(transactionHistory));
      } catch (e) {
        console.error("logTransaction error:", e);
      }
    }

    function restoreTransactionHistory() {
      try {
        const saved = localStorage.getItem("transactionHistory");
        if (!saved) return;
        transactionHistory = JSON.parse(saved);
        const logDiv = document.getElementById("log");
        transactionHistory.forEach((tx, index) => {
          const time = tx.timestamp ? new Date(tx.timestamp).toLocaleTimeString() : new Date().toLocaleTimeString();
          const txLink = tx.txHash ? `<a href="https://polygonscan.com/tx/${tx.txHash}" target="_blank">${tx.txHash}</a>` : '';
          const displayRow = `${time} ${index + 1} ${tx.symbol || ''} BUY ${tx.buyDex || ''} SELL ${tx.sellDex || ''} NET PROFIT, ${tx.actualProfit || ''} ${txLink}<br>`;
          logDiv.innerHTML += displayRow;
        });
      } catch (e) {
        console.error("restoreTransactionHistory error:", e);
      }
    }

    // -------------------------
    // DEX amount helper
    // -------------------------
    // Keep RAW logic; optional callStatic used only when requested.
    async function getAmountOut(router, token, amountIn, useCallStatic = false) {
      try {
        const routerContract = new ethers.Contract(
          router,
          ["function getAmountsOut(uint amountIn, address[] memory path) view returns (uint[] memory)"],
          provider
        );
        const path = [tokens.USDC.address, token];

        let amountsOut;
        if (useCallStatic && routerContract.callStatic && typeof routerContract.callStatic.getAmountsOut === 'function') {
          amountsOut = await routerContract.callStatic.getAmountsOut(amountIn, path);
        } else {
          amountsOut = await routerContract.getAmountsOut(amountIn, path);
        }

        // Normalize using the token's decimals (safer display)
        const tokenContract = new ethers.Contract(token, ["function decimals() view returns (uint8)"], provider);
        const decimals = await tokenContract.decimals();
        const normalized = Number(ethers.utils.formatUnits(amountsOut[1], decimals));
        return normalized;
      } catch (error) {
        throw new Error(`GetAmountOut failed: ${error.message}`);
      }
    }

    // -------------------------
    // SIMPLE LOG
    // -------------------------
    function log(message) {
      const logDiv = document.getElementById("log");
      logDiv.innerHTML = `[${new Date().toLocaleTimeString()}] ${message}<br>` + logDiv.innerHTML;
    }

    // -------------------------
    // CONTROLS: start/stop/pause
    // -------------------------
    document.getElementById('startScan').addEventListener('click', () => {
      isScanning = true;
      startAutoScan();
      log("Auto scan started");
    });
    document.getElementById('stopScan').addEventListener('click', () => {
      isScanning = false;
      clearInterval(scanInterval);
      log("Auto scan stopped");
    });
    document.getElementById('pauseScan').addEventListener('click', () => {
      isScanning = !isScanning;
      log(isScanning ? "Auto scan paused" : "Auto scan resumed");
    });

    // -------------------------
    // EXPORT CSV
    // -------------------------
    document.getElementById('exportCSV').addEventListener('click', function () {
      try {
        if (!transactionHistory || transactionHistory.length === 0) {
          alert("No successful transactions to export.");
          return;
        }
        const headers = ["Time","Session#","Symbol","Buy DEX","Sell DEX","Net Profit (USDC)","Transaction Hash"];
        const csvRows = [headers.join(",")];
        transactionHistory.forEach((tx, index) => {
          const time = tx.timestamp ? new Date(tx.timestamp).toLocaleString() : "";
          const row = [
            `"${time}"`,
            index + 1,
            `"${(tx.symbol || '').replace(/"/g, '""')}"`,
            `"${(tx.buyDex || '').replace(/"/g, '""')}"`,
            `"${(tx.sellDex || '').replace(/"/g, '""')}"`,
            `"${(tx.actualProfit || '').replace(/"/g, '""')}"`,
            `"${(tx.txHash || '').replace(/"/g, '""')}"`
          ];
          csvRows.push(row.join(","));
        });
        const csvContent = csvRows.join("\n");
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const filename = `arb_transactions_${new Date().toISOString().replace(/[:.]/g, '-')}.csv`;
        a.setAttribute('download', filename);
        document.body.appendChild(a);
        try { a.click(); } catch (e) { window.open(url, '_blank'); }
        setTimeout(() => {
          document.body.removeChild(a);
          window.URL.revokeObjectURL(url);
        }, 15000);
      } catch (e) {
        console.error("exportCSV error:", e);
        alert("Export failed: " + e.message);
      }
    });
  </script>
</body>
</html>
